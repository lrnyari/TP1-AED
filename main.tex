\documentclass[10pt,a4paper]{article}

\input{AEDmacros}
\usepackage{caratula} % Version modificada para usar las macros de algo1 de ~> https://github.com/bcardiff/dc-tex


    \titulo{Trabajo práctico 1: Especificación y WP}
\subtitulo{"En búsqueda del camino"}

\fecha{\today}

\materia{Algoritmos y Estructuras de Datos}
\grupo{Grupo NRO}

    \integrante{Roko, Tomás Esteban}{262/23}{tomas.e.roko@gmail.com}
\integrante{Nyari, Lisandro Rafael}{773/24}{lisandronyari@gmail.com}
\integrante{Braslavsky, Lautaro}{827/22}{lautybras@gmail.com}
\integrante{Quintana, Joaquin Ezequiel}{1356/23}{joaquin32flores@gmail.com}

\graphicspath{{../static/}}

% ACÁ TERMINA LA PRIMERA CARILLA.

\begin{document}

% ACÁ ARRANCA LA 2DA CARILLA

\maketitle

\section{Especificación}

\subsection{grandesCiudades}

A partir de una lista de ciudades, devuelve aquellas que tienen más de 50.000 habitantes.

\vspace{2mm}  % DEJO 2mm de espacio VERTICAL (por eso 'V'space). Si quieren dejar espacio en horizontal usan hspace{}
 
%       EJERCICIO 1:


% faltaria revisar casos borde, en particular lista vacía ¿tiene sentido devolver una lista vacía?
\begin{proc}{grandesCiudades}{\In \textit{ciudades} : \TLista{\textit{Ciudad}}}{\TLista{\textit{Ciudad}}}
	\requiere{True}
	\asegura{\paraTodo[unalinea]{i}{\ent}{0 \leq i < |ciudades| \implicaLuego (ciudades[i] \in res \Iff ciudades[i].habitantes > 50000)} \land \\
	\hspace*{1.6cm} \paraTodo[unalinea]{j}{\ent}{0 \leq j < |res| \implicaLuego res[i] \in ciudades}} 
\end{proc}

% \pred{todasMayoresA50k}{ciudades : \TLista{Ciudad}}
% {\paraTodo[unalinea]{i}{\ent}{(0 \leq i < |ciudades|) \implicaLuego ciudades[i].habitantes > 50000}}


% ¡¡IMPORTANTE!!! Es necesario indexar DOS VECES la lista 'ciudades' porque como dice el tp, está compuesta por TUPLAS < nombre, #habitantes>  REVISAR ESTO:                                                                                                          


\vspace{2mm}

%       EJERCICIO 2:



\vspace{4mm}



\subsection{sumaDeHabitantes}

Por cuestiones de planificación urbana, las ciudades registran sus habitantes mayores de edad por un lado y menores de edad por el otro. Dadas dos listas de ciudades del mismo largo con los mismos nombres, una con sus habitantes mayores y otra con sus habitantes menores, este procedimiento debe devolver una lista de ciudades con la cantidad total de sus habitantes.

\vspace{2mm}


\begin{proc}{sumaDeHabitantes}{\In \textit{menoresDeCiudades} : \TLista{\textit{Ciudad}}, \In \textit{mayoresDeCiudades}: \TLista{\textit{Ciudad}}}{\TLista{\textit{Ciudad}}}
	\requiere{\paraTodo[unalinea]{i}{\ent}{0\leq i< |menoresDeCiudades|\implicaLuego menoresDeCiudades[i].nombre = \newline \hspace*{1.7cm} mayoresDeCiudades[i].nombre) \land (|menoresDeCiudades| = |mayoresDeCiudades|)}}
	\asegura{\paraTodo[unalinea]{i}{\ent}{0 \leq i < |res| \implicaLuego res[i].habitantes = menoresDeCiudades[i].habitantes +\newline \hspace*{1.6cm} mayoresDeCiudades[i].habitantes}} 
\end{proc}


\pred{sinRepetir}{ciudades: \TLista{\textit{Ciudad}}}{\paraTodo[unalinea]{i,j}{\ent}{0 \leq i < |ciudades| \land i \neq j \implicaLuego ciudades[i].\textit{nombre} \neq ciudades[j].\textit{nombre}}}


\vspace{4mm}

%       EJERCICIO 3:

\subsection{hayCamino}

 Un mapa de ciudades está conformada por ciudades y caminos que unen a algunas de ellas. A partir de este mapa, podemos definir las distancias entre ciudades como una matriz donde cada celda i, j representa la distancia entre la ciudad i y la ciudad j. Una distancia de 0 equivale a no haber camino entre i y j. Notar que la distancia de una ciudad hacia sí misma es cero y la distancia entre A y B es la misma que entre B y A.
 
 Dadas dos ciudades y una matriz de distancias, se pide determinar si existe un camino entre ambas ciudades
 
 \vspace{2mm}

 
\begin{proc}{hayCamino}{\In \textit{distancias} : \TLista{\TLista{\ent}}, \In \textit{desde}: \ent, \In \textit{hasta}: \ent}{Bool}
	\requiere{matrizCuadradaYSimetrica(distancias) \land 0 \leq desde < |distancias| \land 0 \leq hasta < |distancias|}
	\asegura{res = true \Iff \existe[unalinea]{s}{\TLista{\ent}}{ |s| > 1 \land s[0] = desde \land s[|s| - 1] = hasta \land \\ 
	\hspace*{1.6cm}\paraTodo[unalinea]{j}{\ent}{0 \leq j < |s| \implicaLuego 0 \leq s[j] < |distancias|}} \yLuego \\ 
    \hspace*{1.6cm} \paraTodo[unalinea]{i}{\ent}{(0 < i < |s|) \implicaLuego (distancias[s[i]][s[i-1]] \neq 0)}}
\end{proc}

\pred{matrizCuadradaYSimetrica}{\textit{matriz}: \TLista{\TLista{\ent}}}{
\paraTodo[unalinea]{i}{\ent}{0 \leq i < |matriz| \implicaLuego |matriz[i]| = |matriz|} \yLuego \\
\paraTodo[unalinea]{j,k}{\ent}{0 \leq j,k < |matriz| \implicaLuego matriz[i][j] = matriz[j][i]}
}

%ARREGLAR
%\pred{matrizCuadradaYSimetrica}{\textit{matriz}: \TLista{\TLista{\ent}}}{\paraTodo[unalinea]{i}{\ent}{0 \leq i < |matriz| \implicaLuego |matriz[i]| = |matriz| \land \paraTodo[unaLinea]{j,k}{\ent}{0 \leq j,k < |matriz| \implicaLuego matriz[i][j] = matriz[j][i]}}



\vspace{4mm}

%       EJERCICIO 4:

\subsection{cantidadCaminosNSaltos}

 Dentro del contexto de redes informáticas, nos interesa contar la cantidad de “saltos” que realizan los paquetes de datos, donde un salto se define como pasar por un nodo.

Así como definimos la matriz de distancias, podemos definir la matriz de conexión entre nodo , donde cada celda i, j tiene un 1 si hay un único camino a un salto de distancia entre el nodo i y el nodo j, y un 0 en caso contrario. En este caso, se trata de una matriz de conexión de orden 1, ya que indica cuáles pares de nodos poseen 1 camino entre ellos a 1 salto de distancia.

Dada la matriz de conexión de orden 1, este procedimineto debe obtener aquella de orden n que indica cuántos caminos de n saltos hay entre los distintos nodos. Notar que la multiplicación de una matriz de conexión de orden 1 consigo misma nos da la matriz de conexión de orden 2, y así sucesivamente.

 \vspace{2mm}
 
 \pred{soloUnosyCeros}{matriz: \TLista{\TLista{\ent}}}{\paraTodo[unalinea]{i,j}{\ent}{0 \leq i,j < |matriz| \implicaLuego matriz[i][j] = 0 \lor matriz[i][j] = 1}}
 
 %%\begin{proc}{cantidadCaminosNSaltos}{\Inout \textit{conexión} : \TLista{\TLista{\ent}}, \In \textit{n}: \ent}{}
%	\requiere{}
%	\asegura{} 
%\end{proc}

\vspace{4mm}

%       EJERCICIO 5:

\subsection{caminoMínimo}

 Dada una matriz de distancias, una ciudad de origen y una ciudad de destino, este procedimiento debe devolver la lista de ciudades que conforman el camino más corto entre ambas. En caso de no existir un camino, se debe devolver una lista vacía.

 \vspace{2mm}

 \begin{proc}{caminoMínimo}{\In \textit{origen} : \ent, \In \textit{destino}: \ent, \In \textit{distancias}: \TLista{\TLista{\ent}}}{\TLista{\ent}}
	\requiere{matrizCuadradaYSimetrica(distancias) \land 0 \leq desde < |distancias| \land 0 \leq hasta < |distancias|}
	\asegura{esCamino(distancias,res,desde,hasta) \yLuego \paraTodo[unalinea]{s}{\TLista{\ent}}{esCamino(distancias,s,desde,hasta) \implicaLuego \\ \hspace*{1.5cm} sumarDistancias(distancias,s) \leq sumarDistancias(distancias,res)}}
\end{proc}

\pred{esCamino}{distancias: \TLista{\TLista{\ent}},s: \TLista{\ent}, desde: \ent, hasta: \ent}{
(|s| > 1 \land s[0] = desde \land s[|s| - 1] = hasta \land \paraTodo[unalinea]{j}{\ent}{0 \leq j < |s| \implicaLuego 0 \leq s[j] < |distancias|} \yLuego \\ \paraTodo[unalinea]{i}{\ent}{(0 < i < |s|) \implicaLuego (distancias[s[i]][s[i-1]] \neq 0))}
}

\aux{sumarDistancias}{distancias: \TLista{\TLista{\ent}}, s: \TLista{\ent}}{\ent}{
 \sum_{i=0}^{|\textit{distancias}|-2} distancias[s[i]][s[i+1]]
}



\vspace{8mm}



\section{Demostraciones de correctitud}

La función \textbf{poblaciónTotal} recibe una lista de ciudades donde al menos una de ellas es grande (es decir, supera los 50.000 habitantes) y devuelve la cantidad total de habitantes. Dada la siguiente especificación:

\vspace{2mm}


 \begin{proc}{poblaciónTotal}{\In \textit{ciudades} : \TLista{\textit{Ciudad}}}{\ent}
	\requiere{
		\existe[unalinea]{i}{\ent}{0 \leq i < |\textit{ciudades}| \land \textit{ciudades}[i].\textit{habitantes} > 50,000} \land \\
        \hspace*{1.75cm} \paraTodo[unalinea]{i}{\ent}{0 \leq i < |\textit{ciudades}| \implicaLuego \textit{ciudades}[i].\textit{habitantes} \geq 0} \land \\
        \hspace*{1.75cm} \paraTodo[unalinea]{i,j}{\ent}{0 \leq i < |\textit{ciudades}| \land 0 \leq j < |\textit{ciudades}| \implicaLuego \textit{ciudades}[i].\textit{nombre} \neq \textit{ciudades}[j].\textit{nombre}}
	}
	\vspace{1.5mm}
	
	\asegura{res = \sum_{i=0}^{|\textit{ciudades}|-1} \textit{ciudades}[i].\textit{habitantes}} 

\end{proc}

\vspace{2mm}

Con la siguiente implementación:

\begin{verbatim}
            res = 0
            i = 0
            while (i < ciudades.length) do
                res = res + ciudades[i].habitantes
                i = i + 1
            endwhile
\end{verbatim}

\begin{enumerate}
    \item Demostrar que la implementación es correcta con respecto a la especificación.
    \item Demostrar que el valor devuelto es mayor a 50.000.
\end{enumerate}
%|s| > 1 ∧ s[0] = desde ∧ s[|s| − 1] = hasta ∧
%(∀j : Z) (0 ≤ j < |s| −→L 0 ≤ s[j] < |distancias|)) ∧L
%(∀i : Z) ((0 < i < |s|) −→L (distancias[s[i]][s[i − 1]] 6 = 0))}

\subsection{}
\subsection{}




\vspace{3cm}


\subsection*{Macros de la cátedra para especificar(CON ESTAS DE BASE NOSOTROS NOS ARMAMOS NUESTRAS PRED, AUX, PROD)}

\begin{proc}{nombre}{\In paramIn : \nat, \Inout paramInout : \TLista{\ent}}{tipoRes}
	%    \modifica{parametro1, parametro2,..}
	\requiere{expresionBooleana1}
	\asegura{expresionBooleana2}
	\aux{auxiliar1}{parametros}{tipoRes}{expresion}
	\pred{pred1}{parametros}{expresion} 
\end{proc}

\aux{auxiliarSuelto}{parametros}{tipoRes}{expresion}
% \paraTodo{variable}{tipo}{expresion}
% \existe{variable}{tipo}{expresion}
% Pueden tener [unalinea] para que no se divida en varias lineas
\pred{predSuelto}{parametros}{\paraTodo[unalinea]{variable}{tipo}{algo \implicaLuego expresion}}
\pred{predSuelto}{parametros}{\existe[unalinea]{variable}{tipo}{algo \yLuego expresion}}



\vspace{10cm}


\end{document}
